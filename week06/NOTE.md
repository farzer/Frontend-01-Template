## 状有限态机

- 每个状态都是一个机器
  - 所有的机器接受的输入是一致的
  - 状态机的每个机器本身没有状态，对应纯函数
- 每个机器知道下一个状态
  - 每个机器都有确定的下一个状态（moore状态机）
  - 每个机器根据输入决定下一个状态（mealy状态机）

### mealy 状态机

每个函数是一个状态

```js
function state(c) {
  // 自动编码实现逻辑
  return next;
}

// 调用
while(input) {
  state = state(input)
}
```

## HTML 解析

### 第一步

- 为了方便文件管理，把 parser 单独拆到一个文件中
- parser 接受 HTML 文本作为参数，返回一颗 DOM 树

### 第二步

- 用FSM来实现HTML的分析
- 在HTML标准中，已经规定了HTML的状态
- 只挑选其中一部分状态，完成一个最简单的版本

### 第三步

- 主要的标签有：开始标签，结束标签和自闭合标签
- 暂时忽略属性

### 第四步

- 在状态机中，除了状态迁移，加入业务逻辑
- 在标签结束状态提交 token

### 第五步

- 属性值分为单引号、双引号、无引号三种写法，因此需要较多的状态处理
- 处理属性方式跟标签类似
- 属性结束的时候，把属性加到标签的 token 上

### 第六步

- 从标签构建 DOM 树的基本技巧是使用 栈
- 遇到开始标签时创建元素并入栈，遇到标签结束时出栈
- 自闭合节点可以视为入栈后立刻出栈
- 任何元素的父元素是它入栈前的栈顶

### 第七步

- 文本节点与自封闭标签处理类似
- 多个文本节点需要合并

## CSS Computing

```js
const css = require('css')
const ast = css.parse('body { font-size: 12px; }')
```

### 第一步 收集 CSS 规则

- 遇到 style 标签时，把 css 规则保存起来
- 调用 css parser 来分析解析 css 规则
- 需要分析 css 库对 css 规则的解析格式

### 第二步 调用 css 规则

- 当我们创建一个元素的时候，要立即计算 css
- 理论上，当我们分析一个元素的时候，所有的 css 规则已经收集完毕
- 在真实浏览器中，可能会遇到写在body中的 style 标签，需要重新计算 css 的情况，在本案例中忽略

### 第三步 获取父元素序列

- 在 computeCss 函数中，必须知道元素的父元素才能判断元素与规则是否匹配
- 在上一步的stack中，获取本元素所有的父元素
- 首先应该获取当前元素，所以获取和计算父元素匹配的顺序是从内向外的（css computing实际上也是从右往左计算的）